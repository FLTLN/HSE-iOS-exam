# Темы для контрольной
## Оглавление
- [Темы для контрольной](#темы-для-контрольной)
  - [Оглавление](#оглавление)
  - [Основы Swift](#основы-swift)
    - [Типы данных](#типы-данных)
    - [Операторы](#операторы)
    - [Циклы](#циклы)
    - [Функции](#функции)
    - [Замыкания (closures)](#замыкания-closures)
    - [Протоколы](#протоколы)
    - [Наследование](#наследование)
    - [Расширения протоколов](#расширения-протоколов)
    - [**_спросить Андрея_**](#спросить-андрея)
    - [Структуры и классы](#структуры-и-классы)
- [UI & VC](#ui--vc)
  - [Жизненный цикл View Controller:](#жизненный-цикл-view-controller)
  - [Передача данных между контроллерами](#передача-данных-между-контроллерами)
    - [Делегаты](#делегаты)
- [Коллекции](#коллекции)
- [Многопоточность](#многопоточность)
- [Работа с сетью](#работа-с-сетью)
- [Хранение данных](#хранение-данных)
- [Паттерны и шаблоны проектирования](#паттерны-и-шаблоны-проектирования)

1. [Коллекции](#Коллекции)
2. [Многопоточность](#Многопоточность)
3. [Работа с сетью](#Работа-с-сетью)
4. [Хранение данных](#Хранение-данных)
5. [Паттерны и шаблоны проектирования](#Паттерны-и-шаблоны-проектирования)

## Основы Swift
**Swift** — современный высокоуровневый строго типизированный объектно-ориентированный язык
для iOS и OS X. Он совместим с Objective-C, но привносит много идей и заимствований из других
современных языков: дженерики, функциональный стиль программирования, выведение типов.
Программы на нём рассчитаны на платформы OS X и iOS.
Swift позволяет избежать распространенных ошибок программирования, используя современные
шаблоны программирования:
* Переменные всегда инициализируются перед использованием.
* Индексы массива проверяются на наличие недопустимых ошибок.
* Целые числа проверяются на переполнение.
* Опционалы гарантируют, что значения nil обрабатываются явно.
* Память управляется автоматически.
* Обработка ошибок позволяет контролировать восстановление после непредвиденных сбоев.     

Код Swift компилируется и оптимизируется, чтобы максимально эффективно использовать
современное оборудование.             

[вернуться к оглавлению](#Оглавление)
### Типы данных   

**Объявление констант и переменных**

```swift
let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
var x = 0.0, y = 0.0, z = 0.0
```

**Аннотация типов**


```swift
var welcomeMessage: String
```
Swift - язык со строгой типизацией.     
Swift всегда выбирает Double (вместо Float), когда выводит тип чисел с плавающей точкой:
``` swift
let pi = 3.14159
// pi выводится как тип Double
let anotherPi = 3 + 0.14159
// anotherPi тоже выводится как тип Double даже если есть целый литерал
```

**Простые типы**

* Целые числа: Int, UInt, Int8, Int16,… UInt64
* Числа с плавающей точкой: Double, Float
* Логический тип: Bool имеет значения true, false
``` swift
let i = 1
if i {
 // this example will not compile, and will report an error
}
```

**Строки и символы**

Строка - это серия символов, таких как `"hello, world"`. Строки Swift представлены типом String. Доступ к содержимому строки можно получить различными способами, в том числе в виде набора значений символов.  
Типы Swift String и Character обеспечивают быстрый Unicode-совместимый способ работы с текстом в вашем коде.    
Строковые литералы:
```swift
let singleLineString = "These are the same."
let multilineString = """
These are the same.
"""
```  

**Массивы**

Массив хранит значения того же типа в упорядоченном списке. Одно и то же значение может появляться в массиве несколько раз в разных позициях.   
Пример работы с массивами:
```swift
//Collections
var someInts = [Int] ()
var shoppingList: [String] = ["яйца", "молоко"]
shoppingList[0] = "перепелиные яйца"
shoppingList.insert("хлеб", at: 1)
shoppingList.append("пармезан")
print("for (index, item) in shoppingList.enumerated()")
for (index, value) in shoppingList.enumerated() { //для получения индексов используется enumerated()
 print("\(index + 1)" + ") " + value)
}
print("\nfor item in shoppingList")
for item in shoppingList {
 print(item)
}
```

**Множества**

Множество хранит различные значения одного и того же типа в коллекции без определенного порядка. Объекты должны быть хэшируемы, то есть подчиняться протоколу `Hashable`.   
Пример:
```swift
var set1 = Set<Character>()
set1.insert("A")
set1.insert("B")
set1.insert("C")
var set2: Set<Character> = ["C", "D", "E"]
print("union: \(set1.union(set2))")
print("subtracting: \(set1.subtracting(set2))")
print("intersection: \(set1.intersection(set2))")
print(“symmetricDifference: \(set1.symmetricDifference(set2))")
//union: ["B", "C", "D", "A", "E"]
//subtracting: ["B", "A"]
//intersection: ["C"]
//symmetricDifference: ["D", "E", “A", "B"]
```

**Словари**

В словаре хранятся ассоциации между ключами одного типа и значениями одного типа в коллекции без определенного порядка. Ключи должны быть Hashable.
```swift
var dict = Dictionary<String, String>()
dict.updateValue("торт", forKey: "десерт")
dict["основное блюдо"] = "медальон из говядины"
dict.merge(["напиток" : "квас"]) { (current, _) -> String in
 current
}
print(dict) //["десерт": "торт", "основное блюдо": "медальон из говядины", "напиток": “квас"]
dict["основное блюдо"] = "лазанья"
print(dict) //["десерт": "торт", "напиток": "квас", "основное блюдо": "лазанья"]
dict.removeValue(forKey: "десерт")
print(dict) //["основное блюдо": "лазанья", "напиток": "квас"]
for (key, value) in dict {
 print("\(key) - \(value)")
}
//основное блюдо - лазанья
//напиток - квас
for key in dict.keys {
 print(key)
}
//основное блюдо
//напиток
for key in dict.values {
 print(key)
}
//квас
//лазанья
```

[вернуться к оглавлению](#Оглавление)
### Операторы

[все операторы](https://developer.apple.com/documentation/swift/operator_declarations)     

**Оператор присваивания: = (не возвращает значения)**

```swift
var a = 1
var b = 2
if a = b { // Will produse "Use of '=' in a boolean context, did tou mean '=='?"
}
```

**Арифметические операторы: +, -, \*, /**  

В отличие от арифметических операторов в C и Objective-C, арифметические операторы Swift не допускают переполнения значений по умолчанию. Вы можете выбрать поведение переполнения, используя операторы переполнения Swift (например, a & + b):
```swift
var unsignedOverflow = UInt8.max
// unsignedOverflow equals 255, which is the maximum value a UInt8 can hold
unsignedOverflow = unsignedOverflow &+ 1
// unsignedOverflow is now equal to 0
```
Оператор сложения также поддерживается для конкатенации строк:
```swift
"hello, " + "world" // equals "hello, world”
```

**Оператор получения остатка: %**

```swift
-11 % 5 = -1
```

**Унарный минус: -**

```swift
let three = 3
let minusThree = -three
let plusThree = -minusThree // plusThree equals 3, or "minus minus three"
```
Унарный оператор минус (-) добавляется непосредственно перед значением, с которым он работает, без пробелов.        

**Унарный плюс: +**    

Унарный оператор плюс (+) просто возвращает значение, с которым он работает, без каких-либо изменений:
```swift
let minusSix = -6
let alsoMinusSix = +minusSix // alsoMinusSix equals -6
```

**Составные операторы присваивания: +=, -+, \*=, /=, … (не возвращают значение)**

```swift
var a = 1
a += 2 // a is now equal to 3
```

**Операторы сравнения: ==, <, >, <=, >=, !=, ===, ==**
```swift
(1, "zebra") < (2, "apple") // true because 1 is less than 2; "zebra" and "apple" are not compared
(3, "apple") < (3, "bird") // true because 3 is equal to 3, and "apple" is less than "bird"
(4, "dog") == (4, "dog") // true because 4 is equal to 4, and "dog" is equal to "dog"
("blue", -1) < ("purple", 1) // OK, evaluates to true
("blue", false) < ("purple", true) // Error because < can't compare Boolean values
```

**Операторы диапазона: m…n и m..<n**

```swift
for index in 1...5 {
 print("\(index) times 5 is \(index * 5)")
}
// 1 times 5 is 5
// 2 times 5 is 10
// 3 times 5 is 15
// 4 times 5 is 20
// 5 times 5 is 25
```

**Односторонние диапазоны: n…, …n, ..<n**

```swift
let names = ["Anna", "Alex", "Brian", “Jack”]
for name in names[..<2] {
 print(name)
}
// Anna
// Alex
let range = ...5
range.contains(7) // false
range.contains(4) // true
range.contains(-1) // true
```

**Логические Операторы: !, &&, ||**

Логические операторы изменяют или объединяют значения логической логики true и false. Swift поддерживает три стандартных логических оператора в языках на основе C:      
> **Важно**     
> Логические операторы Swift && и || являются левоассоциативными, что означает, что составные выражения с несколькими логическими операторами сначала оценивают крайнее левое подвыражение.   

**Тернарные операторы: a ? b : c** - имеет возвращаемое значение  

**Сравнение множеств**

* Оператор «равно» (==), чтобы определить, содержат ли два множества все одинаковые значения.
* Метод `isSubset (of :)`, чтобы определить, содержатся ли все значения множества в указанном множестве.
* Метод `isSuperset (of :)`, чтобы определить, содержит ли множество все значения в указанном множестве.
* Методы `isStrictSubset (of :)` или `isStrictSuperset (of :)`, чтобы определить, является ли множества подмножеством или надмножеством, но не равным указанному множеству.
* Метод `isDisjoint (with :)`, чтобы определить, не имеют ли два множества общих значений.

**Конкатенация строк и символов**

```swift
let string1 = "hello"
let string2 = " there"
var welcome = string1 + string2
// welcome now equals "hello there"
let exclamationMark: Character = "!"
welcome.append(exclamationMark)
```

**Интерполяция строк**

```swift
let someInt = Int.random(in: 0...100)
print("some int from 0 to 100 is \(someInt)")
//some int from 0 to 100 is 8
```

**Подсчет символов**

```swift
var word = "cafe"
print("the number of characters in \(word) is \(word.count)")
// Prints "the number of characters in cafe is 4"
word += "\u{301}" // COMBINING ACUTE ACCENT, U+0301
print("the number of characters in \(word) is \(word.count)")
// Prints "the number of characters in café is 4"
```

**Вставка и удаление**

Чтобы вставить один символ в строку по указанному индексу, используйте метод `insert (_: at :)`, а для вставки содержимого другой строки по указанному индексу используйте метод `insert (contentsOf: at :)`.
Чтобы удалить один символ из строки по указанному индексу, используйте метод `remove (at :)`, а для удаления подстроки в указанном диапазоне используйте метод `removeSubrange (_ :)`:
```swift
var welcome = "hello"
welcome.insert("!", at: welcome.endIndex)
// welcome now equals "hello!"
welcome.insert(contentsOf: " there", at:
welcome.index(before: welcome.endIndex))
// welcome now equals "hello there!"
```

**Сравнение строк**

Swift предоставляет три способа сравнения текстовых значений: равенство строк и символов, равенство префиксов и равенство суффиксов.
Равенство строк и символов проверяется с помощью оператора «равно» (==) и оператора «не равно» (! =):

```swift
// "Voulez-vous un café?" using LATIN SMALL LETTER E WITH ACUTE
let eAcuteQuestion = "Voulez-vous un caf\u{E9}?"
// "Voulez-vous un café?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT
let combinedEAcuteQuestion = "Voulez-vous un caf\u{65}\u{301}?"
if eAcuteQuestion == combinedEAcuteQuestion {
    print("These two strings are considered equal")
}
// Prints "These two strings are considered equal”
```

**Префикс и суффикс**

Чтобы проверить, имеет ли строка определенный префикс или суффикс строки, вызовите методы `hasPrefix (_ :)` и `hasSuffix (_ :)` строки, оба из которых принимают один аргумент типа String и возвращают логическое значение.

[вернуться к оглавлению](#Оглавление)

### Циклы 

**Цикл For-in**   
Вы используете цикл `for-in` для итерации последовательности, такой как элементы в массиве, диапазоны чисел или символы в строке.
```swift
var array = [1, 2, 3, 4, 5]
for item in array {
    print("item = \(item)")
}
//item = 1
//item = 2
//item = 3
//item = 4
//item = 5
```

**Цикл while**

Цикл while выполняет набор операторов до тех пор, пока условие не станет ложным. Такие циклы лучше всего использовать, когда число итераций неизвестно до начала первой итерации.   
Swift предоставляет два вида циклов `while`:   
while оценивает свое состояние в начале каждого прохода цикла.   
`repeat-while` оценивает свое состояние в конце каждого прохода через цикл.   
Вот общая форма цикла `while`:   
```swift
while condition {
    statements
}
```
Вот общая форма цикла `repeat-while`:
```swift
repeat {
    statements
} while condition
```

**If**

В простейшем виде оператор `if` имеет единственное условие `if`. Он выполняет набор операторов, только если это условие истинно. Условные выражения в Swift работают как и в других C подобных языках:   
```swift
let a = 10
let b = 2
if a < b {
    print("\(a) < \(b)")
} else if a > b {
    print("\(a) > \(b)")
} else {
    print("\(a) == \(b)")
}
```

**switch**

Оператор `switch` рассматривает значение и сравнивает его с несколькими возможными шаблонами сопоставления. Затем он выполняет соответствующий блок кода на основе первого шаблона, который успешно соответствует. Оператор `switch` предоставляет альтернативу оператору if для ответа на несколько потенциальных состояний.   
В своей простейшей форме оператор `switch` сравнивает значение с одним или несколькими значениями одного
типа:
```swift
switch some value to consider {
case value 1:
 respond to value 1
case value 2, value 3:
 respond to value 2 or 3
default:
 otherwise
```

**Continue**

Оператор `continue` указывает циклу прекратить то, что он делает, и начать снова в начале следующей итерации цикла. Он говорит: «Я закончил с текущей итерацией цикла», не выходя из цикла вообще.
В следующем примере удаляются все гласные и пробелы из строчной строки для создания загадочной фразы-головоломки:
```swift
let puzzleInput = "great minds think alike"
var puzzleOutput = ""
let charactersToRemove: [Character] = ["a", "e", "i", "o", "u", " "]
for character in puzzleInput {
    if charactersToRemove.contains(character) {
        continue
    }
    puzzleOutput.append(character)
}
print(puzzleOutput)
// Prints "grtmndsthnklk"
```

**Break**

Оператор break немедленно завершает выполнение всего оператора потока управления. Оператор `break` можно использовать внутри оператора `switch` или цикле, если вы хотите прекратить выполнение оператора `switch` или цикле раньше, чем в противном случае.


**Fallthrough**
В Swift операторы `switch` не попадают в нижнюю часть каждого дела и переходят к следующему.   
Привязка значений
```swift
let result = Result<String, Error>.success("Success")
var value = ""
switch result {
case .success(let string): //привязка значения
    value = string
    Fallthrough //провалиться в следующий кейз
default:
    print("value == " + value)
}
//value == Success
```

**Маркированные инструкции**

Метка пишется в той же строке, что и ключевое слово начала инструкции, которое следует после метки через двоеточие. Ниже приведен пример синтаксиса цикла `while`, хотя принцип работы маркера такой же со всеми инструкциями:
```swift
for1label: for i in 0...10 {
    var string = ""
    for j in 0...10 {
        string += "\(j)"
        if i == j {
        print(string)
            continue for1label
        }
    }
}
```

**Guard**

```swift
func greet(person: [String: String]) {
    guard let name = person["name"] else {
        return
    }
    print("Hello \(name)!")
    guard let location = person["location"] else {
        print("I hope the weather is nice near you.")
        return
    }
    print("I hope the weather is nice in \(location).")
}
greet(person: ["name": "John"])
// Prints "Hello John!"
// Prints "I hope the weather is nice near you."
greet(person: ["name": "Jane", "location": "Cupertino"])
// Prints "Hello Jane!"
```

**Проверка доступности API**

```swift
if #available(platform name version, ..., *) {
    statements to execute if the APIs are available
} else {
    fallback statements to execute if the APIs are unavailable
}
```

[вернуться к оглавлению](#Оглавление)

### Функции

Функции - это отдельные фрагменты кода, которые выполняют определенную задачу. Вы даете функции имя, которое определяет, что она делает, и это имя используется для «вызова» функции для выполнения ее задачи, когда это необходимо.
```swift
func greet(person: String) -> String {
    let greeting = "Hello, " + person + "!"
    return greeting
}
func sayHelloWorld() -> String {
    return "hello, world"
}
func greet(person: String) {
    print("Hello, \(person)!")
}
```

**Функции с несколькими возвращаемыми значениями**

Вы можете использовать тип кортежа в качестве возвращаемого типа для функции, которая возвращает несколько значений как часть одного составного возвращаемого значения. В приведенном ниже примере определяется функция minMax (array :), которая находит самые маленькие и самые большие числа в массиве значений Int:
```swift
func minMax(array: [Int]) -> (min: Int, max: Int)? {
    if array.isEmpty { return nil }
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..<array.count] {
        if value < currentMin {
            currentMin = value
        } else if value > currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}
```

**Функции с неявным возвратом**

Если все тело функции является одним выражением, функция неявно возвращает это выражение. Например, обе функции ниже имеют одинаковое поведение:
```swift
func greeting(for person: String) -> String {
 "Hello, " + person + "!"
}
print(greeting(for: "Dave"))
// Prints "Hello, Dave!"
func anotherGreeting(for person: String) -> String {
 return "Hello, " + person + "!"
}
print(anotherGreeting(for: "Dave"))
// Prints "Hello, Dave!"
```

**Вариативные параметры**

Параметр с переменным значением принимает ноль или более значений указанного типа. В приведенном ниже примере вычисляется среднее арифметическое для списка чисел любой длины:
```swift
func arithmeticMean(_ numbers: Double...) -> Double {
 var total: Double = 0
 for number in numbers {
 total += number
 }
 return total / Double(numbers.count)
}
arithmeticMean(1, 2, 3, 4, 5)
// returns 3.0, which is the arithmetic mean of these five numbers
arithmeticMean(3, 8.25, 18.75)
// returns 10.0, which is the arithmetic mean of these three numbers
```
> **Важно**   
> Функция может иметь не более одного вариативного параметра.

**Типы функций**

Каждая функция имеет определенный тип функции, состоящий из типов параметров и типа возврата функции.   
Например:
```swift
func addTwoInts(_ a: Int, _ b: Int) -> Int {
 return a + b
}
func multiplyTwoInts(_ a: Int, _ b: Int) -> Int {
 return a * b
}
```
Этот пример определяет две простые математические функции, называемые addTwoInts и multiplyTwoInts. Каждая из этих функций принимает два значения Int и возвращает значение Int, которое является результатом выполнения соответствующей математической операции.
Тип обеих этих функций `(Int, Int) -> Int`. Это можно прочитать как: «Функция, которая имеет два параметра, оба типа Int, и которая возвращает значение типа Int».

**Вложенные функции**
```swift
func chooseStepFunction(backward: Bool) -> (Int) -> Int {
 func stepForward(input: Int) -> Int { return input + 1 }
 func stepBackward(input: Int) -> Int { return input - 1 }
 return backward ? stepBackward : stepForward
}
var currentValue = -4
let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)
// moveNearerToZero now refers to the nested stepForward() function
while currentValue != 0 {
 print("\(currentValue)... ")
 currentValue = moveNearerToZero(currentValue)
}
print("zero!")
// -4...
// -3...
// -2...
// -1...
```

[вернуться к оглавлению](#Оглавление)

### Замыкания (closures)   

Замыкания - это автономные блоки функциональности, которые можно передавать и использовать в вашем коде. Замыкания в Swift похожи на блоки в C и Objective-C и на лямбды в других языках программирования.   
Замыкания могут захватывать и хранить ссылки на любые константы и переменные из контекста, в котором они определены. Эта процедура известна как заключение этих констант и переменных, отсюда и название "замыкание". Swift выполняет всю работу с управлением памятью при захвате за вас.  

>Заметка   
>Не волнуйтесь, если вы не знакомы с понятием "захвата"(capturing). Это объясняется более подробно ниже в пункте Захват значений.   

Замыкания принимают одну из трех форм:
* Глобальные функции - это замыкания, которые имеют имя и не захватывают никаких значений.
* Вложенные функции - это замыкания, которые имеют имя и могут захватывать значения из своей вмещающей функции.
* Выражения замыканий - это безымянные замыкания, написанные в упрощенном синтаксисе, которые могут захватывать значения из окружающего контекста.   

Выражения замыкания в Swift имеют четкий, ясный, оптимизированный синтаксис в распространенных сценариях. Эти оптимизации включают:

- Вывод типа параметра и возврат типа значения из контекста
- Неявные возвращающиеся значения однострочных замыканий
- Сокращенные имена параметров
- Синтаксис последующих замыканий   

**Функции как замыкания**   
Функции — это частный случай замыканий, так как они обладают следующими свойствами:   
- группируют код для многократного использования;
- могут быть многократно вызваны посредством назначенного им имени;
- могут быть переданы в качестве аргументов.   

Рассмотрим работу с замыканиями на примерах.Напишем функцию, которая будет принимать на входе массив-кошелек и возвращать массив всех сторублевых купюр из этого кошелька
``` swift
// функция отбора купюр
func handle100(wallet: [Int]) -> [Int] {
    var returnWallet = [Int]()
    for banknot in wallet {
        if banknot==100{
            returnWallet.append(banknot)
        }
    }
    return returnWallet
}
// электронный кошелек
var wallet = [10,50,100,100,5000,100,50,50,500,100]
handle100(wallet: wallet)
```
При каждом вызове функция handle100(wallet:) будет возвращать массив сторублевых купюр. Здесь handle100(wallet:) — это замыкание, так как оно обладает описанными ранее свойствами:
- группирует код;
- может быть многократно использовано;
- может быть передано в виде аргумента.   
  
Расширим функционал кода, написав дополнительную функцию для отбора купюр достоинством 1000 рублей и более.
``` swift
func handleMore1000(wallet: [Int]) -> [Int] {
    var returnWallet = [Int]()
    for banknot in wallet {
        if banknot>=1000{
            returnWallet.append(banknot)
        }
    }
    return returnWallet
}
var wallet = [10,50,100,100,5000,100,50,50,500,100]
handleMore1000(wallet: wallet)
```
В результате получается, что при написании двух функций в значительной мере происходит дублирование кода. Разница функций handle100(wallet:) и handleMore1000(wallet:) лишь в проверяемом условии. Остальной код в функциях один и тот же.   
Для решения этой проблемы можно пойти двумя путями:
1. реализовать весь функционал в пределах одной функции и передавать условие в виде аргумента;
2. реализовать три функции. Первая будет группировать повторяющийся код и принимать в виде аргумента одну из оставшихся функций, которые, в свою очередь, будут производить операцию сравнения.   

Если мы пойдем по первому пути, то при увеличении количества различных условий отбора единая функция будет разрастаться и в конце концов станет нечитабельной и слишком сложной. Поэтому воспользуемся вторым вариантом.
``` swift
// единая функция формирования результирующего массива
func handle(wallet: [Int], closure: (Int) -> Bool) -> [Int] {
    var returnWallet = [Int]()
    for banknot in wallet {
        if closure(banknot) {
            returnWallet.append(banknot)
        }
    }
    return returnWallet
}
// функция сравнения с числом 100
func compare100(banknot: Int) ->Bool {
    return banknot==100
}
// функция сравнения с числом 1000
func compareMore1000(banknot:Int) -> Bool {
    return banknot>=1000
}
var wallet = [10,50,100,100,5000,100,50,50,500,100]
handle(wallet: wallet, closure: compare100)
handle(wallet: wallet, closure: compareMore1000)
```
Функция handle(wallet:closure:) получает в качестве входного параметра closure одну из функций проверки условия и в операторе if вызывает переданную функцию. Функции проверки принимают на входе анализируемую купюру и возвращают Bool в зависимости от результата сравнения.  
Чтобы получить купюры определенного достоинства, необходимо вызвать функцию handle(wallet:closure:) и передать в нее имя одной из функций проверки.   
В итоге мы получим очень качественный код, который достаточно легко расширять
  
**Замыкающие выражения**   

Представим, что возникла необходимость написать функции для отбора купюр по многим и многим условиям (найти все полтинники, все купюры достоинством менее 1000 рублей, все купюры, которые без остатка делятся на 100, и т. д.). Условий отбора может быть великое множество. В определенный момент писать отдельную функцию проверки для каждого из них станет довольно тяжелой задачей, так как для того, чтобы использовать единую функцию проверки, необходимо знать имя проверяющей функции, а их могут быть десятки.   
В подобной ситуации куда более эффективным становится использование замыкающих выражений.   
Замыкающие выражения — это безымянные замыкания, написанные
в облегченном синтаксисе   

Синтаксис:
```
{ (parameters) -> return type in
 statements
} 
```

Замыкающее выражение пишется в фигурных скобках. После указания перечня входных аргументов и типа возвращаемого значения ставится ключевое слово in, после которого следует тело замыкания.   
В соответствии с третьим свойством замыканий замыкающие выражения можно передавать в качестве аргументов. Давайте вызовем написанную ранее функцию handle(wallet:closure:), передавая
ей замыкающее выражение в качестве входного параметра 
``` swift
// отбор купюр достоинством выше 1000 рублей
handle(wallet: wallet: wallet, closure: {(banknot: Int) -> Bool in
    return banknot>=1000
})
// отбор купюр достоинством 100 рублей
handle(wallet: wallet: wallet, closure: {(banknot: Int) -> Bool in
    return banknot==100
})
```
В результате необходимость в существовании функций compare100(banknot:) и compareMore1000(banknot:) отпадает, так как код проверяющей функции передается напрямую в качестве аргумента closure.     
Налицо увеличение гибкости и уменьшение объема кода.   

>ПРИМЕЧАНИЕ:   
>Облегченный синтаксис замыкающих выражений упрощает работу и позволяет не писать лишний код, а оптимизированный код экономит время и приносит вам дополнительную выгоду.   

Теперь приступим к оптимизации уже используемых замыкающих выражений. При объявлении входного параметра closure в функции handle(wallet:closure:) указывается его функциональный тип (он принимает функцию типа (Int) -> Bool), поэтому при передаче замыкающего выражения нет необходимости дублировать данную информацию.
``` swift
// отбор купюр достоинством выше 1000 рублей
handle(wallet: wallet, closure: {banknot in
    return banknot>=1000
})
// отбор купюр достоинством 100 рублей
handle(wallet: wallet, closure: {banknot in
    return banknot==100
})
```
В замыкающем выражении перед ключевым словом in необходимо передать только имя, которое будет присвоено передаваемому в него значению очередного элемента массива wallet.   
В коде функции handle при вызове функции closure ей передается параметр banknot — именно по этой причине мы указываем в качестве входного аргумента переменную с аналогичным названием.

**Последующие замыкания**   

Если вам нужно передать выражение замыкания функции в качестве последнего аргумента функции и само выражение замыкания длинное, то оно может быть записано в виде последующего замыкания. Последующее замыкание - замыкание, которое записано в виде замыкающего выражения вне (и после) круглых скобок вызова функции, даже несмотря на то, что оно все еще является аргументом функции. Когда вы используете синтаксис последующего замыкания, то вы не должны писать ярлык аргумента замыкания в качестве части вызова самой функции. Функция может включать в себя несколько последующих замыканий, однако, первые несколько примеров используют по одному последующему замыканию:

```swift
func someFunctionThatTakesAClosure(closure: () -> Void) {
 // function body goes here
}
// Here's how you call this function without using a trailing closure:
someFunctionThatTakesAClosure(closure: {
 // closure's body goes here
})
// Here's how you call this function with a trailing closure instead:
someFunctionThatTakesAClosure() {
 // trailing closure's body goes here
}
```   
Если выражение замыкания является единственным аргументом функции, и вы пишете его используя синтаксис последующего замыкания, то вы можете опустить написание круглых скобок вызова самой функции после ее имени.   

``` swift
reversedNames = names.sorted { $0 > $1 }
```

Последующие замыкания полезны в случаях, когда само замыкание достаточно длинное, и его невозможно записать в одну строку. В качестве примера приведем вам метод map(_:) типа Array в языке Swift, который принимает выражение замыкания как его единственный аргумент. Замыкание вызывается по одному разу для каждого элемента массива и возвращает альтернативную отображаемую величину (возможно другого типа) для этого элемента. Природа отображения и тип возвращаемого значения определяется замыканием.   

После применения замыкания к каждому элементу массива, метод map(_:) возвращает новый массив, содержащий новые преобразованные величины, в том же порядке, что и в исходном массиве.   

Вот как вы можете использовать метод map(_:) вместе с последующим замыканием для превращения массива значений типа Int в массив типа String. Массив [16, 58, 510] используется для создания нового массива ["OneSix", "FiveEight", "FiveOneZero"] :

``` swift
let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
```
Код выше создает словарь отображающий цифры и их английскую версию имен. Так же он объявляет массив целых значений для преобразования в массив строк.

Вы можете использовать массив numbers для создания значений типа String, передав замыкающее выражение в метод map(\_:) массива в качестве последующего замыкания. Обратите внимание, что вызов numbers.map не включает в себя скобки после map, потому что метод map(_:) имеет только один параметр, который мы имеем в виде последующего замыкания:
``` swift
let strings = numbers.map { (number) -> String in
    var number = number
    var output = ""
    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0
    return output
}

//тип строк был выведен как [String]
//значения ["OneSix", "FiveEight", "FiveOneZero"]
```
Метод map(_:) вызывает замыкание один раз для каждого элемента массива. Вам не нужно указывать тип входного параметра замыкания, number, так как тип может быть выведен из значений массива, который применяет метод map.

В этом примере переменная number инициализирована при помощи значения параметра замыкания number, так что значение может быть изменено внутри тела замыкания. (Параметры функций и замыкания всегда являются константами.) Выражение замыкания так же определяет возвращаемый тип String для указания типа, который будет храниться в массиве на выходе из метода map(_:).

Замыкающее выражение строит строку, названную output, каждый раз, когда оно вызывается. Оно рассчитывает последнюю цифру number, используя оператор деления с остатком ( number % 10 ) и использует затем эту получившуюся цифру, чтобы найти соответствующую строку в словаре digitNames. Это замыкание может быть использовано для создания строкового представления любого целого числа, большего чем 0.

>Заметка:   
>Вызов словаря digitNames синтаксисом сабскрипта сопровождается знаком (!), потому что сабскрипт словаря возвращает опциональное значение, так как есть такая вероятность, что такого ключа в словаре может и не быть. В примере выше мы точно знаем, что number % 10 всегда вернет существующий ключ словаря digitNames, так что восклицательный знак используется для принудительного извлечения значения типа String в возвращаемом опциональном значении сабскрипта.

Строка, полученная из словаря digitNames, добавляется в начало переменной output, путем правильного формирования строковой версии числа наоборот.(Выражение number % 10 дает нам 6 для 16, 8 для 58 и 0 для 510).

Переменная number после вычисления остатка делится на 10. Так как тип значения Int, то наше число округляется вниз, таким образом 16 превращается в 1, 58 в 5, 510 в 51.

Процесс повторяется пока number /= 10 не станет равным 0, после чего строка output возвращается замыканием и добавляется к выходному массиву функции map(_:).

Использование синтаксиса последующих замыканий в примере выше аккуратно инкапсулирует функциональность замыкания сразу после функции map(_:), которой замыкание помогает, без необходимости заворачивания всего замыкания внутрь внешних круглых скобок функции map(_:).

Если функция принимает несколько последюущих замыканий, вы можете пропустить ярлык параметра для первого из них, а для остальных уже указать нужно. Например, функция ниже загружает изображение в фотогалерею:
``` swift
func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {
    if let picture = download("photo.jpg", from: server) {
        completion(picture)
    } else {
        onFailure()
    }
}
```
Когда вы вызываете эту функцию для загрузки изображений, вы используете два замыкания. Первое замыкание - это обработчик, который отображает изображение после успешной загрузки. Второе замыкание - обработчик, который отображает ошибку пользователю, если произошла ошибка во время загрузки.
```swift
loadPicture(from: someServer) { picture in
    someView.currentPicture = picture
} onFailure: {
    print("Couldn't download the next picture.")
}
```
В это примере метод loadPicture(from:completion:onFailure:) передает свою сетевую задачу в фоновый поток и вызывает одно из замыканий, когда сетевая задача выполнена. Написание функции таким способом позволяет вам разделять код, который ответственен за обработку ошибки во время сетевой задачи от кода, который отвечает за успешную загрузку.

**Захват значений**   

Если вы понимаете этот код и его смысл в этом разделе, "Захват значений" вам можно не читать)
``` swift
func testCaptureValues() {
 print("\n\ntestCaptureValues():")
 var a = 1
 let block = {
    a *= 2
    print("in block: a = \(a)")
 }
 a += 1
 block()
}
testCaptureValues()
//
//
//testCaptureValues():
//in block: a = 4
```   
Замыкания могут захватывать константы и переменные из окружающего контекста, в котором оно объявлено. После захвата замыкание может ссылаться или модифицировать значения этих констант и переменных внутри своего тела, даже если область, в которой были объявлены эти константы и переменные уже больше не существует.

В Swift самая простая форма замыкания может захватывать значения из вложенных функций, написанных внутри тела других функций. Вложенная функция может захватить любые значения из аргументов окружающей ее функции, а так же константы и переменные, объявленные внутри тела внешней функции.

Вот пример функции makeIncrementer, которая содержит вложенную функцию incrementer. Вложенная функция incrementer() захватывает два значения runningTotal и amount из окружающего контекста. После захвата этих значений incrementer возвращается функцией makeIncrementer как замыкание, которое увеличивает runningTotal на amount каждый раз как вызывается.
```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
   var runningTotal = 0
   func incrementer() -> Int {
      runningTotal += amount
      return runningTotal
   }
   return incrementer
}
```
Возвращаемый тип makeIncrementer Void -> Int. Это значит, что он возвращает функцию, а не простое значение. Возвращенная функция не имеет параметров и возвращает Int каждый раз как ее вызывают. Узнать как функции могут возвращать другие функции можно в главе "Функциональные типы как возвращаемые типы".

Функция makeIncrementer(forIncrement:) объявляет целочисленную переменную runningTotal, для хранения текущего значения инкрементора, которое будет возвращено. Переменная инициализируется значением 0.

Функция makeIncrementer(forIncrement:) имеет единственный параметр Int с внешним именем forIncrement и локальным именем amount. Значение аргумента передается этому параметру, определяя на сколько должно быть увеличено значение runningTotal каждый раз при вызове функции.

Функция makeIncrementer объявляет вложенную функцию incrementer, которая непосредственно и занимается увеличением значения. Эта функция просто добавляет amount к runningTotal и возвращает результат.

Если рассматривать функцию incrementer() отдельно, то она может показаться необычной:
```swift
func incrementer() -> Int {
    runningTotal += amount
    return runningTotal
}
```
Функция incrementer() не имеет ни одного параметра и она ссылается на runningTotal и amount внутри тела функции. Она делает это, захватывая существующие значения от runningTotal и amount из окружающей функции и используя их внутри. Захват ссылки дает гарантию того, что runningTotal не исчезнет при окончании вызова makeIncrementer и гарантирует, что runningTotal останется переменной в следующий раз, когда будет вызвана функция incrementer().

>Заметка   
>В качестве оптимизации Swift может захватить и хранить копию значения, если это значение не изменяется самим замыканием, а так же не изменяется после того, как замыкание было создано. Swift также берет на себя управление памятью по утилизации переменных, когда они более не нужны.

Приведем пример makeIncrementer в действии:
```swift
let incrementByTen = makeIncrementer(forIncrement: 10)
```
Этот пример заставляет константу incrementByTen ссылаться на функцию инкрементора, которая добавляет 10 к значению переменной runningTotal каждый раз как вызывается. Многократный вызов функции показывает ее в действии:
```swift
incrementByTen()
// возвращает 10
incrementByTen()
// возвращает 20
incrementByTen()
// возвращает 30
```
Если вы создаете второй инкрементор, он будет иметь свою собственную ссылку на новую отдельную переменную runningTotal :
```swift
let incrementBySeven = makeIncrementer(forIncrement: 7)
incrementBySeven()
//возвращает значение 7
```
Повторный вызов первоначального инкрементора ( incrementByTen ) заставит увеличиваться его собственную переменную runningTotal и никак не повлияет на переменную, захваченную в incrementBySeven :
```swift
incrementByTen()
//возвращает 40
```

**Замыкания являются ссылочными типами**   
Если вы понимаете этот код и его смысл в этом разделе, "Замыкания являются ссылочными типами" вам можно не читать)
``` swift
var a = 1
let block = {
 a *= 2
 print("in block: a = \(a)")
}
a += 1
block()
let block2 = block
block2()
//in block: a = 4
//in block: a = 8
```   
Когда бы вы ни присваивали функцию или замыкание константе или переменной, вы фактически присваиваете ссылку этой константе или переменной на эту функцию или замыкание. В

Это так же значит, что если вы присвоите замыкание двум разным константам или переменным, то оба они будут ссылаться на одно и то же замыкание:   

```swift 
//если вы не понимаете, что происходит, выше есть код
let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()
//возвращает 50

incrementByTen()
//возвращает 60
```
Пример выше показывает, что вызов alsoIncrementByTen то же самое, что и вызов incrementByTen. Потому что и та и другая функция ссылаются на одно и то же замыкание: и то, и другое замыкание возвращают один и тот же runningTotal.

**Escaping Closures (Сбегающие замыкания)**   
Когда говорят, что замыкание сбегает из функции, то это значит, что это замыкание было передано в функцию в качестве аргумента и вызывается уже после того, как функция вернула значение. Когда вы объявляете функцию, которая имеет замыкание в качестве одного из параметров, то вы пишете @escaping до типа параметра, для того чтобы указать, что замыкание может сбежать.   

Если замыкание хранится в переменной, которая была объявлена вне функции, а затем эта переменная была передана в качестве аргумента в функцию, то получается, что замыкание, которое посредством переменной передается в функцию, сбегающее. В качестве примера можно рассмотреть функции, которые выполняют асинхронные операции в завершающем обработчике, который является замыканием. То есть получается, что функция завершает свою работу, после чего вызывается завершающий обработчик. Или другими словами обработчик не вызывается, пока не завершится работа функции, таким образом получается, что данному замыканию нужно сбежать из области работы функции, чтобы отработать позже. Например:
``` swift
var completionHandlers: [() -> Void] = []
func someFunctionWithEscapingClosure(completionHandler:
@escaping () -> Void) {
 completionHandlers.append(completionHandler)
}
```
По умолчанию все замыкания @nonescaping   

Функция someFunctionWithEscapingClosure(_:) принимает и добавляет в массив замыкание, объявленное за пределами функции. Если вы не поставите маркировку @escaping, то получите ошибку компиляции.

Сбегающее замыкание, которое имеет ссылку на self требует отдельного рассмотрения, если self ссылается на экземпляр класса. Захватывая self в сбегающем замыкании, вы можете случайно создать зацикленность сильных ссылок.   

Обычно замыкание захватывает переменные неявно, просто используя их внутри тела, но в случае с self вам нужно делать это явно. Если вы хотите захватить self, напишете self явно, когда используете его, или включите self в лист захвата замыкания. Когда вы пишете self явно, вы явно указываете свое намерение, а так же помогаете сами себе тем, что напоминаете проверить наличие цикла сильных ссылок. Например, в коде ниже замыкание переданное в метод someFunctionWithEscapingClosure(\_:) ссылается на self явно. А вот замыкание, переданное в метод someFunctionWithNonescapingClosure(_:) является несбегающим, что значит, что оно может ссылаться на self неявно.
``` swift
func someFunctionWithNonescapingClosure(closure: () -> Void) {
    closure()
}
 
class SomeClass {
    var x = 10
    func doSomething() {
        someFunctionWithEscapingClosure { self.x = 100 }
        someFunctionWithNonescapingClosure { x = 200 }
    }
}
 
let instance = SomeClass()
instance.doSomething()
print(instance.x)
// Выведет "200"
 
completionHandlers.first?()
print(instance.x)
// Выведет "100"
```
**Autoclosures**   

Автоматическое закрытие - это замыкание, которое создается автоматически для переноса выражения, передаваемого в качестве аргумента функции.   
``` swift
var names = ["Alexey", "Irina", "Agata"]
let getName = {
 return names.remove(at: 0)
}
func helloSomeBody(nameProvider: @autoclosure ()-> String) {
 let name = nameProvider()
 print("Hello \(name)!!!")
}
helloSomeBody(nameProvider: getName())
helloSomeBody(nameProvider: getName())
helloSomeBody(nameProvider: getName())
helloSomeBody(nameProvider: "Mikhail")
//test autoclosure:
//Hello Alexey!!!
//Hello Irina!!!
//Hello Agata!!!
//Hello Mikhail!!!
```   

Автозамыкания позволяют вам откладывать вычисления, потому как код внутри них не исполняется, пока вы сами его не запустите. Это полезно для кода, который может иметь сторонние эффекты или просто является дорогим в вычислительном отношении, потому что вы можете контролировать время исполнения этого кода.   
``` swift
var arrayOfNames = ["Helga", "Bazil", "Alex"]
func printName(nextName: String ) {
    // какой-либо код
    print(nextName)
}
printName(arrayOfNames.remove(at: 0))
//test autoclosure:
//Helga
```
При каждом вызове функции printName(nextName:) в качестве входного значения ей передается результат вызова метода remove(at:) массива arrayOfNames.   
Независимо от того, в какой части функции будет использоваться переданный параметр (или не будет использоваться вовсе), значение, возвращаемое методом remove(at:), будет вычислено в момент вызова функции printName(nextName:). Получается, что передаваемое значение вычисляется независимо от того, нужно ли оно в ходе выполнения функции.   
Отличным решением данной проблемы станет использование ленивых вычислений, то есть таких вычислений, которые будут выполняться лишь в тот момент, когда это понадобится. Для того чтобы реализовать этот подход, можно передавать в функцию printName(nextName:) замыкание, которое будет вычисляться в тот момент, когда к нему обратятся.
```swift
var arrayOfNames = ["Helga", "Bazil", "Alex"]
func printName(nextName: ()->String) {
    // какой-либо код
    print(nextName())
}
printName({arrayOfNames.remove(at: 0)})
//test autoclosure:
//Helga
```
Для решения этой задачи потребовалось изменить тип входного параметра nextName на ()->String и заключить передаваемый метод remove(at:) в фигурные скобки. Теперь внутри реализации функции printName(nextName:) к входному аргументу nextName необходимо обращаться как к самостоятельной функции (с использованием круглых скобок после имени параметра). Таким образом, значение метода remove(at:) будет вычислено именно в тот момент, когда оно понадобится, а не в тот момент, когда оно будет передано. Единственным недостатком данного подхода является то, что входной параметр должен быть заключен в фигурные скобки, а это несколько усложняет использование функции и чтение кода.   
С помощью автозамыканий можно использовать положительные функции обоих рассмотренных примеров: отложить вычисление переданного значения и передавать значение в виде значения (без фигурных скобок).   

Для того чтобы реализовать автозамыкание, требуется, чтобы выполнялись следующие требования.
- Входной аргумент должен иметь функциональный тип.   
  В примере, приведенном ранее, аргумент nextName уже имеет функциональный тип ()->String.
- Функциональный тип не должен определять типы входных параметров.   
  В примере типы входных параметров не определены (пустые скобки).
- Функциональный тип должен определять тип возвращаемого значения.   
  В примере тип возвращаемого значения определен как String.
- Переданное выражение должно возвращать значение того же типа, которое определено в      функциональном типе замыкания.   
  В примере передаваемая в качестве входного аргумента функция возвращает значение типа String точно так же, как определено функциональным типом входного аргумента.
- Перед функциональным типом необходимо использовать атрибут @autoclosure.   
- Передаваемое значение должно указываться без фигурных скобок.   

Перепишем код в соответствии с указанными требованиями:
``` swift
var arrayOfNames = ["Helga", "Bazil", "Alex"]
func printName(nextName: @autoclosure ()->String) {
    // какой-либо код
    print(nextName())
}
printName(arrayOfNames.remove(at: 0))
//test autoclosure:
//Helga
```
Теперь метод remove(at:) передается в функцию printName(nextName:) как обычный аргумент, без использования фигурных скобок, но внутри тела используется как самостоятельная функция. Ярким примером глобальной функции, входящей в стандартные возможности Swift и использующей механизм автозамыканий, является функция assert(condition:message:file:line:). Аргументы condition и message — это автозамыкания, первое из которых вычисляется только в случае активного debug-режима, а второе — только в случае, когда condition соответствует false.   

[вернуться к оглавлению](#Оглавление)   

### Протоколы   

Протокол представляет собой объявление группы методов, и нициализаторов и свойств, которым должны соответствовать класс, структура и перечисление, предоставляя их реализации.   
Протоколы нередко служат для определения объектов, называемых [делегатами](#Делегаты) и предоставляющих перехватчики, позволяющие специально настраивать поведение библиотечных или каркасных классов, реагировать на события и выполнять прочие действия.   

В качестве примера ниже приведено определение протокола Resizable.   
``` swift
protocol Resizable {
    var width : Float { get set }
    var height : Float { get set }

    init ( width : Float , height : Float )
    func res i zeBy ( wFactor : Float , hFactor : Float ) -> Void
}
```   
В этом объявлении протокола Resizable требуется, чтобы в любом типе данных, соответствующем этому протоколу, предоставлялись два свойства, один инициализатор и одна функция. Обратите внимание на то, что в самом протоколе ничего не определяется, а только предписывается то, что должно быть непременно реализовано в соответствующем ему типе данных. В качестве примера ниже приведен класс Rectangle, соответствующий протоколу Resizable.   
``` swift
class Rectangle : Resizable , Printable {
    var width : Float
    var height : Float
    var description : String {
        return " Rectangle , width \( width ) , height \( height ) "
    }

    required init ( width : Float , height : Float ) {
        self. width = width
        self. height = height
    }
    func resizeBy ( wFactor : Float, hFactor : Float ) -> Void {
        width *= wFactor
        height *= hFactor
    }
}
```   

Тип, указывающий в объявлении класса на его соответствие конкретному протоколу, состоит из имени этого протокола, после которого обычно следует имя базового класса, если таковой существует/ Приведенный выше класс соответствует протоколам Resizable и CustomStringConvertible, определенным в стандартной библиотеке Swift.   
Как видите, в данном классе предоставляется конкретная реализация средств, требующихся по протоколу. Так, если в протоколе требуется реализовать инициализатор, то такой инициализатор должен быть обозначен ключевым словом required, как показано выше.   
___
> Заметка:   
> Вам не нужно обозначать реализацию инициализаторов протокола модификатором required в классах, где стоит модификатор final, потому что конечные классы не могут иметь подклассы.   

Если подкласс переопределяет назначенный инициализатор суперкласса и так же реализует соответствующий протоколу инициализатор, то обозначьте реализацию инициализатора сразу двумя модификаторами required и override:

``` swift
protocol SomeProtocol {
    init()
}
 
class SomeSuperClass {
    init() {
        // реализация инициализатора…
    }
}
 
class SomeSubClass: SomeSuperClass, SomeProtocol {
    // "required" от соответсвия протоколу SomeProtocol; "override" от суперкласса SomeSuperClass
    required override init() {
        // реализация инициализатора…
    }
}
```
___
Экземпляры типов данных, соответствующих протоколу, могут присваиваться переменным типа этого протокола, как показано ниже.  
``` swift
let r: Resizable = Rectangle ( width : 10, height : 20)
```   
Для соответствия протоколу Printable требуется, чтобы в типе данных было реализовано свойство description, предназначенное для представления в удобочитаемом виде описания этого типа данных? если таковое потребуется. В частности, данное свойство используется в том случае, если экземпляр типа данных, соответствующего протоколу, передается в качестве аргумента функции print(), как показано ниже.
``` swift
let rect = Rectangle ( width : 10, height : 20)
print ( rect ) // Выводит строку " Rectangle , width 10.О, height 20.О"
```
Соответствие протоколу CustornStringConvertiЫe требует от типа наличия свойства типа String? которое используется, когда необходимо представление типа, доступное для чтения человеком. В частности, это свойство используется, когда экземпляр соответствующего типа передается как аргумент функции print ():   
``` swift
let rect = Rectangle ( width : 10, height : 20)
print ( rect ) // Выводит строку " Rectangle , width 10.0, height 20 .0" 
```

Шаблон кода с протоколом:  
``` swift
protocol SomeProtocol {
 // определение протокола…
}
struct SomeStructure: FirstProtocol, AnotherProtocol {
 // определение структуры…
}
class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
 // определение класса…
}
```   
**Что может требовать протокол?**
``` swift
// Свойства
protocol SomeProtocol {
 var mustBeSettable: Int { get set }
 var doesNotNeedToBeSettable: Int { get }
}
// Методы
protocol SomeProtocol {
 static func someTypeMethod()
}
// Изменяющий Методы
protocol Togglable {
 mutating func toggle()
}
// Инициализатор
protocol SomeProtocol {
 init(someParameter: Int)
 ``` 

**Протоколы как типы данных**   

Протокол сам по себе не несет какой-либо функциональной нагрузки, он лишь содержит требования к реализации объектных типов. Тем не менее протокол является полноправным типом данных. Используя протокол в качестве типа данных, вы указываете на то, что записываемое в данное хранилище значение должно иметь тип данных, который соответствует указанному протоколу.   

Любой протокол становится полноправным типом, который вы можете использовать в вашем коде:
- Как тип параметра или возвращаемый тип в функции, методе, инициализаторе
- Как тип константы, переменной или свойства
- Как тип элементов массива, словаря или другого контейнера   

>Заметка:   
>Из-за того что протоколы являются типами, то их имена начинаются с заглавной буквы (как в случае FullyNamed или RandomNumberGenerator) для соответствия имен с другими типами Swift (Int, String, Bool, Double…)

Вот пример использования протокола в качестве типа:
``` swift
class Dice {
 let sides: Int
 let generator: LinearCongruentialGenerator
 init(sides: Int, generator: LinearCongruentialGenerator) {
 self.sides = sides
 self.generator = generator
 }
 func roll() -> Int {
 return Int(generator.random() * Double(sides)) + 1
 }
}
```
Этот пример определяет новый класс Dice, который отображает игральную кость с n количеством сторон для настольной игры. Экземпляры Dice имеют свойство sides, которое отображает количество сторон, которое они имеют, так же кубики имеют свойство generator, которое предоставляет генератор случайных чисел, из которого и берутся значения броска игрального кубика.

Свойство generator имеет тип RandomNumberGenerator, таким образом вы можете использовать в этом свойстве экземпляр любого типа, соответствующий протоколу RandomNumberGenerator. Больше ничего не требуется от экземпляра, присваемого этому свойству, кроме того, что этот экземпляр должен принимать протокол RandomNumberGenerator.

Dice так же имеет инициализатор для установки начальных значений. Этот инициализатор имеет параметр generator, который так же является типом RandomNumberGenerator. Вы можете передать значение любого соответствующего протоколу типа в этот параметр, когда инициализируете новый экземпляр Dice.

Dice предоставляет один метод экземпляра - roll, который возвращает целое значение от 1 и до количества сторон на игральной кости. Этот метод вызывает генератор метода random(), для создания нового случайного числа от 0.0 и до 1.0, а затем использует это случайное число для создания значения броска игральной кости в соответствующем диапазоне (1…n). Так как мы знаем, что generator принимает RandomNumberGenerator, то это гарантирует нам, что у нас будет метод random().

Вот как используется класс Dice для создания шестигранной игральной кости с экземпляром LinearCongruentialGenerator в качестве генератора случайных чисел:

``` swift
var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
for _ in 1...5 {
    print("Бросок игральной кости равен \(d6.roll())")
}
// Бросок игральной кости равен 3
// Бросок игральной кости равен 5
// Бросок игральной кости равен 4
// Бросок игральной кости равен 5
// Бросок игральной кости равен 4
```

**Делегирование**   

Делегирование - это паттерн(шаблон), который позволяет классу или структуре передавать некоторую ответственность экземпляру другого типа.  
Этот шаблон реализуется определением протокола, который инкапсулирует делегируемые полномочия.

**Условное соответствие протоколу**   

Шаблонный тип может удовлетворять требованиям протокола только при определенных условиях, например, когда общий параметр типа соответствует протоколу. Вы можете сделать общий тип условно соответствующим протоколу, указав ограничения при расширении типа. Напишите эти  граничения после имени протокола, который вы используете, написав оговорку where.

Следующее расширение делает экземпляры Array совместимыми с TextRepresentable протоколом всякий раз, когда они хранят элементы типа, которые соответствуют TextRepresentable:
```swift
extension Array: TextRepresentable where Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return "[" + itemsAsText.joined(separator: ", ") + "]"
    }
}
let myDice = [d6, d12]
print(myDice.textualDescription)
// Prints "[A 6-sided dice, A 12-sided dice]"
```

**Принятие протокола через расширение** 
Если тип уже соответствует всем требованиям протокола, но еще не заявил, что он принимает этот протокол, то вы можете сделать это через пустое расширение:
```swift
struct Hamster {
    var name: String
    var textualDescription: String {
        return "Хомяка назвали \(name)"
    }
}
extension Hamster: TextRepresentable {}
```
Экземпляры Hamster теперь могут быть использованы в тех случаях, когда нужен тип TextRepresentable:
```swift
let simonTheHamster = Hamster(name: "Фруша")
let somethingTextRepresentable: TextRepresentable = simonTheHamster
print(somethingTextRepresentable.textualDescription)
// Выведет "Хомяка назвали Фруша"
```
>Заметка   
>Типы не принимают протоколы автоматически, если они удовлетворяют их требованиям. Принятие протокола должно быть объявлено в явной форме.   

**Коллекции типов протокола**   

Протоколы могут использовать в качестве типов, которые хранятся в таких коллекциях как массивы или словари. Это делает массив более универсальным.
```swift
let things: [TextRepresentable] = [game, d12, simonTheHamster]
```

**Наследование протокола**

Протокол может наследовать другие протоколы, может добавлять требования поверх тех требований протоколов, которые он наследует.
```swift
protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
 // определение унаследованного протокола
} 
```

**Классовые протоколы**   

Вы можете ограничить протокол так, чтобы его могли принимать только классы.   
Используйте протоколы class-only, когда поведение, определяемое протоколом, предполагает или требует, что соответствующий проколу тип должен быть ссылочного типа.
```swift
protocol SomeClassOnlyProtocol: AnyObject, SomeInheretedProtocol {
 // Определение протокола class-only
}
```

В примере выше SomeClassOnlyProtocol может быть принят только классом. Если вы попытаетесь принять протокол SomeClassOnlyProtocol структурой или перечислением, то получите ошибку компиляции.

**Проверка соответствия протоколу**   

Вы можете использовать операторы _is_ и _as_ для проверки соответствия протоколу:
- Оператор _is_ возвращает значение true, если экземпляр соответствует протоколу и возвращает false, если нет.
- Опциональная версия оператора понижающего поведения _as?_ Возвращает опциональное значение типа протокола, и это значение равно nil, если оно не соответсвует протоколу.
- Принудительная версия оператора понижающего поведения as осуществляет принудительное понижающее приведение, и если оно не завершается успешно, то выскакивает runtime ошибка.

Пример оператора _AS_:
```swift
for object in objects {
    if let objectWithArea = object as? HasArea {
        print("Площадь равна \(objectWithArea.area)")
        } else {
            print("Что-то такое что не имеет площади")
        }
}
```
[вернуться к оглавлению](#Оглавление) 

### Наследование   

Класс может наследовать методы, свойства и другие характеристики другого класса.   
Суперкласс (родитель), подкласс (потомок).   
Наследование - поведение, которое отделяет классы от других типов.   
Базовый класс - любой класс, который ничего не наследует из другого класса.   
Базовый принцип ООП.   
В Swift нет базового класса.   
В Objective-C это NSObject    

**Наследование подклассом**   

```swift
class SomeSubclass: SomeSuperclass {
  // определение подкласса проводится тут
}
```   
Подклассы сами могут создавать подклассы.

**Переопределение**   
Подклассы могут проводить свои собственные реализации методов экземпляра, методов класса, свойств экземпляра, свойств класса или индекса, который в противном случае будет наследовать от суперкласса. Это известно как переопределение.

Для переопределения характеристик, которые все равно будут унаследованы, вы приписываете к переписываемому определению ключевое слово override. Делая так, вы показываете свое намерение провести переопределение, и что оно будет сделано не по ошибке. Переписывание по случайности может вызвать непредвиденное поведение, и любое переопределение без ключевого слова override, будет считаться ошибкой при компиляции кода.

Ключевое слово override так же подсказывает компилятору Swift проверить, что вы переопределяете суперкласс класса (или один из его параметров), который содержит то определение, которое вы хотите переопределить. Эта проверка гарантирует, что ваше переопределение корректно.   

**Переопределение методов**   

Предположим, что класс Train унаследован от класса Vehicle, в котором определена метод makeNoise. Вот как будет выглядеть его переопределение в классе Train:     

```swift
class Train: Vehicle {
    override func makeNoise() {
        print("Чу-чу")
    }
} 
```

**Переопределение свойств**   

Вы можете переопределить унаследованные свойства класса или экземпляра для установки вашего собственного геттера и сеттера для этого свойства, или добавить наблюдателя свойства для наблюдения за переопределяемым свойством, когда меняется лежащее в основе значение свойства.   

**Переопределения геттеров и сеттеров свойства**   
```swift
class Car: Vehicle {
    var gear = 1
    override var description: String {
        return super.description + " на передаче \(gear)"
    }
}
```
Переопределение свойства description начинается с super.description, который возвращает свойство description класса Vehicle. Версия класса Car свойства description добавляет дополнительный текст в конец описания текущего свойства description.   

**Предотвращение переопределений**   
Вы можете предотвратить переопределение метода, свойства или индекса, обозначив его как конечный.   
Сделать это можно написав ключевое слово final перед ключевым словом метода, свойства или индекса
```swift
class SomeClass {
    final var someVar: String = ""
    final func someFunc() {}
    final class func someClassFunc() {}
}
```

[вернуться к оглавлению](#Оглавление)   

### Расширения протоколов   

Протоколы могут быть расширены для обеспечения метода и реализации свойства соответствующими типами. Это позволяет вам самостоятельно определить поведение по протоколам, а не по индивидуальному соответствию каждого типа или глобальной функции.   

Расширения добавляют новую функциональность существующему типу класса, структуры или перечисления. Расширения в Swift могут:   
- Добавлять вычисляемые свойства и вычисляемые свойства типа
- Определять методы экземпляра и методы типа
- Предоставлять новые инициализаторы
- Определять сабскрипты (индексы)
- Определять новые вложенные типы
- Обеспечить соответствие существующего типа протоколу

Расширение объявляется с помощью ключевого слова _extension_

Например, протокол RandomNumberGenerator может быть расширен для предоставления метода randomBool(), который использует результат требуемого метода random() для возвращения случайного значения типа Bool:   
```swift
protocol RandomNumberGenerator {
    func random() -> Double
}

extension RandomNumberGenerator {
    func randomBool() -> Bool {
        return random() > 0.5
    }
}
```
Путём создания расширения для протокола все подходящие типы автоматически получат эту реализацию метода без всяких дополнительных изменений.   

___
# **_спросить Андрея_**

**Опциональные требования протокола**   

Опциональные требования должны иметь префиксный модификатор optional в качестве части определения протокола. Опциональные требования доступны для кода, который вы пишете, так что вы можете интерполировать его с кодом на Objective-C. И протокол и опциональное требование должны иметь атрибут @objc. Обратите внимание, что протоколы с маркировкой @objc могут приниматься только классами, но не структурами или перечислениями.

Когда вы используете опциональное требование свойства или метода, то их тип автоматически становится опциональным. Например, тип метода (Int) -> String становится ((Int) -> String)?. Обратите внимание, что весь тип функции обернут в опциональное значение, а не только возвращаемое значение функции.

Опциональное требование протокола может быть вызвано при помощи опциональной цепочки, чтобы учесть возможность того, что требование не будет реализовано типом, который соответствует протоколу. Вы проверяете реализацию опционального метода, написав вопросительный знак после имени метода, когда он вызывается, например someOptionalMethod?(someArgument).

Следующий пример определяет класс Counter, который использует источник внешних данных для предоставления значение их инкремента. Этот источник внешних данных определен протоколом CounterDataSource, который имеет два опциональных требования:   
```swift
@objc protocol CounterDataSource {
    @objc optional func increment(forCount count: Int) -> Int
    @objc optional var fixedIncrement: Int { get }
} 
```
Протокол CounterDataSource определяет опциональное требование метода increment(forCount:) и опциональное требование свойства fixedIncrement. Эти требования определяют два разных способа для источника данных для предоставления подходящего значения инкремента для экземпляра Counter.
```swift
protocol Printable {
    func canPrint() -> Bool
}
extension Printable {
    func canPrint() -> Bool {
        return true
    }
}
```
Обеспечение реализации по умолчанию
Вы можете использовать расширение протокола, чтобы обеспечить реализацию по
умолчанию для любого метода или требования свойства этого протокола. Если
соответствующий тип предоставляет свою собственную реализацию требуемого
метода или свойства, то реализация будет использоваться вместо той, которая
предоставляется расширением. 

[вернуться к оглавлению](#Оглавление)  

### Структуры и классы

В отличие от других языков программирования, Swift не требует создавать отдельные файлы для интерфейсов и реализаций пользовательских классов и структур. В Swift, вы объявляете структуру или класс в одном файле, и внешний интерфейс автоматически становится доступным для использования в другом коде.   

Структуры и классы - это универсальные, гибкие конструкции, которые становятся строительными блоками кода вашей программы. Вы определяете свойства и методы для добавления функциональности к своим структурам и классам, используя тот же синтаксис, который вы используете для определения констант, переменных и функций.   

**Сравнение структур и классов**   

Структуры и классы в Swift имеют много общего. Оба могут:   
- Определять свойства для хранения значений
- Определять методы для обеспечения функциональности
- Определять сабскрипты для предоставления доступа к их значениям с использованием синтаксиса индексов
- Определять инициализаторы, чтобы установить их начальное состояние
- Расширяться, чтобы расширить их функциональность за пределы реализации по умолчанию
- Соответствовать протоколам, чтобы обеспечить стандартную функциональность определенного вида   

У классов есть дополнительные возможности, которых нет у структур:
- Наследование позволяет одному классу наследовать характеристики другого.
- Приведение типов позволяет проверять и интерпретировать тип экземпляра класса во время выполнения.
- Деинициализаторы позволяют экземпляру класса освобождать любые ресурсы, которые он назначил.
- Подсчет ссылок позволяет использовать более одной ссылки на экземпляр класса.   

Ситнтаксис: 
```swift
class SomeClass {
    // здесь пишется определение класса
}
struct SomeStructure {
    // здесь пишется определение структуры
}
```

Синтаксис для образования экземпляра класса или структуры очень схож:
```swift
let someResolution = Resolution()
let someVideoMode = VideoMode()
```

**Доступ к свойствам**   

Вы можете получить доступ к свойствам экземпляра, используя точечный синтаксис. В точечном синтаксисе имя свойства пишется сразу после имени экземпляра, а между ними вписывается точка (.) без пробелов.

**Поэлементные инициализаторы структурных типов**   

Все структуры имеют автоматически генерированный "поэлементный инициализатор", который вы можете использовать для инициализации свойств новых экземпляров структуры. Начальные значения для свойств нового экземпляра могут быть переданы поэлементному инициализатору по имени:

```swift
struct Resolution {
    var width = 0
    var height = 0
}
let vga = Resolution(width: 640, height: 480)
```

**Структуры и перечисления - типы значения**   

Тип значения - это тип, значение которого копируется, когда оно присваивается константе или переменной, или когда передается функции.

Все базовые типы Swift - типы значений и реализованы они как структуры.

Рассмотрим пример, который использует структуру Resolution из предыдущего примера:

```swift
let hd = Resolution(width: 1920, height: 1080)
var cinema = hd
```
если поменять элемент внутри структуры hd, то cinema все равно не изменится.   

То же поведение применимо к перечислениям:
```swift
enum CompassPoint {
    case north, south, east, west
    mutating func turnNorth() {
        self = .north
    }
}
var currentDirection = CompassPoint.west
let rememberedDirection = currentDirection
currentDirection.turnNorth()

print("Текущее направление - \(currentDirection)")
// Выведет "Текущее направление - north"
```

**Классы - ссылочный тип**   

В отличии от типа значений, ссылочный тип не копируется, когда его присваивают переменной или константе, или когда его передают функции. Вместо копирования используется ссылка на существующий экземпляр.

```swift
//создали экземляр класса, потом изменили значения полей
let tenEighty = VideoMode()
tenEighty.resolution = hd
tenEighty.interlaced = true
tenEighty.name = "1080i"
tenEighty.frameRate = 25.0
```

Следующее, что мы сделаем, это tenEighty присвоим новой константе alsoTenEighty и изменим частоту кадров:   
```swift
let alsoTenEighty = tenEighty
alsoTenEighty.frameRate = 30.0
```
Так как это классы ссылочного типа, то экземпляры tenEighty и alsoTenEighty ссылаются на один и тот же экземпляр VideoMode. Фактически получается, что у нас два разных имени для одного единственного экземпляра.

Если мы проверим свойство frameRate у tenEighty, то мы увидим, что новая частота кадров 30.0, которая берется у экземпляра VideoMode.

**Идентификационные операторы**   

Идентичен (===)   
Не идентично (! ==)   
Используйте эти операторы, чтобы проверить, относятся ли
две константы или переменные к одному и тому же экземпляру.
```swift
if tenEighty === alsoTenEighty {
    print("tenEighty and alsoTenEighty refer to the same VideoMode instance.")
}
// Выведет "tenEighty and alsoTenEighty refer to the same VideoMode instance."
```

Обратите внимание, что «идентичность» (в виде трех знаков равенства, или ===) не имеет в виду «равенство» (в виде двух знаков равенства, или ==). Идентичность или тождественность значит, что две константы или переменные ссылаются на один и тот же экземпляр класса.

[вернуться к оглавлению](#Оглавление)  

# UI & VC   

## Жизненный цикл View Controller:

Информация взята [отсюда](https://medium.com/good-morning-swift/ios-view-controller-life-cycle-2a0f02e74ff5).   

Жизненный цикл `Viev Controller` можно описать этим графиком:

![](https://miro.medium.com/max/700/1*jb1Y17gwQCRi2XCKy7_QHQ.png)

Для переходов между состояниями используются следующие методы:

**loadView**  

Этот метод используется, когда `View Controller` создается из кода. Лучше ничего не делать с этим методом, если `View Controller` создан из `.xib` или `storyboard`.

**viewDidLoad**

Этот метод загружается один раз в жизненном цикле `View Controller`. Он вызывается, когда все `view` загружены. В этом методе можно выполнить некоторые общие задачи:   

1. сетевой вызов, который нужен один раз.
2. пользовательский интерфейс
3. Другие задачи, которые нужно выполнить один раз  

> Примечание:    
> этот вызов метода перед определением границ и поворотом. Поэтому опасно работать с размером `view` в этом методе. 

**viewWillAppear**  

Этот метод вызывается каждый раз перед тем, как `view` станет видимым, и перед настройкой какой-либо анимации. В этом методе `view` имеет привязку, но ориентация еще не установлена. Вы можете переопределить этот метод для выполнения настраиваемых задач, связанных с отображением представления, например, для скрытия полей или отключения действия до того, как `view` станет видимым.

**viewWillLayoutSubviews**   

It don’t do Nothing by default. When a view’s bounds change, the view adjusts the position of its subviews. View controller can override this method to make changes before the view lays out its subviews.    

Когда границы `view` изменяются, `view` корректирует положение своих `subview`. `View Controller` может переопределить этот метод, чтобы внести изменения до того, как `view` разместит `subview`.

**viewDidLayoutSubviews**   

Этот метод вызывается после того, как `View Controller` был настроен на свое `subview` после изменения его границы. Добавьте сюда код, если вы хотите внести изменения в `subview` после того, как они были установлены. 

**viewDidAppear**   

Этот метод вызывается после того, как `view` отобразится на экране. Используется для сохраненея данных, запуска анимации, воспроизведения видео и звука, загрузки данных из сети.

**viewWillDisappear**   

Этот метод вызывается до того, как `view` будет удалено из иерархии `view`. `view` все еще находятся в иерархии `view`, но еще не удалены, какие-либо анимации выгрузки еще не настроены. Добавьте сюда код для обработки таймеров, скрытия клавиатуры, отмены сетевых запросов, возврата любых изменений в родительский интерфейс. Также это идеальное место для сохранения состояния.  

**viewDidDisappear**

Этот метод вызывается после того, как `view` был удален из иерархии `view`. Используйте этот метод, чтобы прекратить прослушивание уведомлений или датчиков устройства.  

**deinit**  

Before a view controller is removed from memory, it gets deinitialized. You usually override deinit() to clean resources that the view controller has allocated that are not freed by ARC. Keep in mind that just because a VC is no longer visible, doesn’t mean that it has been deallocated. Container view controllers such as NavigationController can keep their VCs available in memory. Keep in mind that even though a VC is off screen, if it is still in memory, it still works normally and can receive notifications.   

**didReceiveMemoryWarning**   

When memory starts to fill up, iOS does not automatically move data from memory to its limited hard disk space. It does, however, issue this warning and YOU (I mean YOU) are responsible for clearing some objects out of memory. Be aware that if the memory of your app goes over a certain threshold, iOS will shutdown your app. Unfortunately, this will look like a crash to the end user.
viewWillTransition(to:with:)
When the interface orientation changes, UIKit calls this method on the window’s root view controller before the size changes are about to be made. The root view controller then notifies its child view controllers, propagating the message throughout the view controller hierarchy. The parameter to contains the new CGSize size of the container’s view and the parameter with contains a UIViewControllerTransitionCoordinator coordinator, an enum that describes the new orientation.

> TODO:     
> Layout, UIViewController methods
> UIKit & Storyboard (IBOutlets)

[вернуться к оглавлению](#Оглавление) 

## Передача данных между контроллерами   




### Делегаты  

# Коллекции
# Многопоточность
# Работа с сетью
# Хранение данных
# Паттерны и шаблоны проектирования

https://swiftbook.ru/content/languageguide/